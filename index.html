<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css" id="theme">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Rust futures - an introduction</h1>
					<h2><i>Max Bruckner</i></h2>
				</section>
				<section>
					<h2>What is a Future</h2>
					<div class="fragment shrink" data-fragment-index="0">
						<p><b>A representation of a value that may not be yet available but will in the <em>future</em>.</b></p>
					</div>
					<div class="fragment" data-fragment-index="0">
						<p>aka <em>Promise</em></p>
						<p><b>A <em>promise</em> that there will be a value, even if there is none yet.</b></p>
					</div>
				</section>

				<section>
					<section>
						<h2>Example</h2>
						<ol>
							<li><em>download</em> image</li>
							<li class="fragment"><em>convert</em> into different format</li>
						</ol>
					</section>
					<section>
						<h3>Synchronously</h3>
						<pre><code data-trim data-noescape class="language-rust" >
							<script type="text/template">
							fn fetch_and_convert(url: Url) -> Result {
								let image = download(url)?;  // waiting for network
								convert(image)              // CPU intensive
							}
							</script>
						</code></pre>
					</section>
					<section>
						<h3>Synchronously</h3>
						<pre class="fragment shrink" data-fragment-index="0"><code data-trim data-noescape class="language-plaintext" >
							<script type="text/template">
							download -------->
							  âŒš              |
							  âŒš              |
							  âŒš            network
							  âŒš              |
							  âŒš <------------+
							conversion
								ðŸ”¥
								ðŸ”¥ cpu intensive work
								ðŸ”¥
								âœ…
							</script>
						</code></pre>
						<ul class="fragment" data-fragment-index="0">
							<li>not bad so far</li>
							<li>need to wait anyways(?)</li>
							<li>might block though</li>
						</ul>
						<aside class="notes">
							Might block GUI thread or server backend.
						</aside>
					</section>
					<section>
						<h3>Synchronous loop</h3>
						<pre class="fragment shrink" data-fragment-index="0"><code data-trim data-noescape class="language-rust" >
							<script type="text/template">
							fn fetch_and_convert(url: Url) -> Result {
								let image = download(url)?;  // waiting for network
								convert(image)              // CPU intensive
							}
							</script>
						</code></pre>
						<pre class="fragment" data-fragment-index="0"><code data-trim data-noescape class="language-rust" >
							<script type="text/template">
							for url in urls.iter() {
								fetch_and_convert(url);
							}
							</script>
						</code></pre>
					</section>
					<section>
						<h3>Synchronous loop</h3>
						<pre><code data-trim data-noescape class="language-plaintext" >
							<script type="text/template">
							0 download -->
							    âŒš        |
							    âŒš <------+
							  conversion
							    ðŸ”¥
							    âœ…
							1        download -->
							           âŒš        |
							           âŒš <------+
							           conversion
							           ðŸ”¥
							           âœ…
							2               âž
							</script>
						</code></pre>
					</section>
					<section>
						<h3>Threading</h3>
						<pre class="fragment shrink" data-fragment-index="0"><code data-trim data-noescape class="language-rust" >
							<script type="text/template">
								let mut handles = Vec::new();

								for url in urls.into_iter() {
									handles.push(spawn(move || fetch_and_convert(url)));
								}

								handles.into_iter().for_each(JoinHandle::join);
							</script>
						</code></pre>
						<div class="fragment shrink" data-fragment-index="1">
							<pre class="fragment" data-fragment-index="0"><code data-trim data-noescape class="language-plaintext" >
								<script type="text/template">
								download -->   download -->   download -->
								  âŒš        |    âŒš        |    âŒš        |
								  âŒš <------+    âŒš <------+    âŒš <------+   â€¦
								  conversion   conversion     conversion
								  ðŸ”¥             ðŸ”¥             ðŸ”¥
								  âœ…             âœ…             âœ…
								</script>
							</code></pre>
						</div>
						<ul class="fragment" data-fragment-index="1">
							<li>OS scheduling overhead</li>
							<li>hard to compose</li>
							<li>collecting results</li>
							<aside class="notes">
								There are better solutions than the example (like threadpools etc.), but these problems still hold.
								Also the better solutions already are kind of like futures.
							</aside>
						</ul>
					</section>
					<section>
						<h3>bad composability</h3>
						<pre class="fragment shrink" data-fragment-index="0"><code data-trim data-noescape class="language-rust">
							<script type="text/template">
								type Gallery = Vec<Url>;

								fn convert_gallery(gallery: Gallery) {
									let mut handles = Vec::new();

									for url in gallery.into_iter() {
										handles.push(spawn(move || fetch_and_convert(url)));
									}

									handles.into_iter().for_each(JoinHandle::join);
								}
							</script>
						</code></pre>
						<div class="r-stack">
						<div class="fragment shrink" data-fragment-index="1">
							<pre class="fragment" data-fragment-index="0"><code data-trim data-noescape class="language-rust">
								<script type="text/template">
									fn convert_galleries(galleries: Vec<Gallery>) {
										let mut handles = Vec::new();

										for gallery in galleries.into_iter() {
											handles.push(spawn(move || convert_gallery(gallery)));
										}

										handles.into_iter().for_each(JoinHandle::join);
									}
								</script>
							</code></pre>
						</div>
						<p class="fragment" data-fragment-index="1">ðŸ˜¢</p>
						</div>
					</section>
				</section>

				<section>
					<section>
						<h2>Futures</h2>
					</section>
					<section>
						<h3>async-await semantics</h3>
						<div class="fragment shrink" data-fragment-index="0">
							<pre><code data-trim data-noescape class="language-rust" >
								<script type="text/template">
								async fn download(url: Url) -> Result { â€¦ }
								</script>
							</code></pre>
							<pre><code data-trim data-noescape class="language-rust" >
								<script type="text/template">
								async fn convert(image: Image) -> Result { â€¦ }
								</script>
							</code></pre>
						</div>
						<pre class="fragment" data-fragment-index="0"><code data-trim data-noescape class="language-rust" >
							<script type="text/template">
							async fn fetch_and_convert(url: Url) -> Result {
								let image = download(url).await?;
								convert(image).await
							}
							</script>
						</code></pre>
						<p class="fragment">suspended on await</p>
					</section>
					<section>
						<h3>old syntax</h3>
						<div class="fragment shrink" data-fragment-index="0">
							<pre><code data-trim data-noescape class="language-rust" >
								<script type="text/template">
									fn download(url: Url) -> impl Future<Output = Result> { â€¦ }
								</script>
							</code></pre>
							<pre><code data-trim data-noescape class="language-rust" >
								<script type="text/template">
									fn convert(image: Image) -> impl Future<Output = Result> { â€¦ }
								</script>
							</code></pre>
						</div>
						<pre class="fragment" data-fragment-index="0"><code data-trim data-noescape class="language-rust" >
							<script type="text/template">
								async fn fetch_and_convert(url: Url)
										-> impl Future<Output = Result> {
									download(url)
										.and_then(|image| convert(image))
								}
							</script>
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>implementations</h2>
						<p>Ways this could be implemented</p>
						<p>(and is, roughly, in many languages).</p>
					</section>
					<section>
						<h3>callbacks</h3>

						<div class="fragment shrink" data-fragment-index="0">
							<pre><code data-trim data-noescape class="language-rust" >
								<script type="text/template">
									fn download(url: Url, callback: impl FnOnce(Image)) { â€¦ }
								</script>
							</code></pre>
							<pre><code data-trim data-noescape class="language-rust" >
								<script type="text/template">
									fn convert(image: Image, callback: impl FnOnce(Converted)) { â€¦ }
								</script>
							</code></pre>
							<small>without error handling for simplicity</small>
						</div>
						<pre class="fragment" data-fragment-index="0"><code data-trim data-noescape class="language-rust" >
							<script type="text/template">
								fn fetch_and_convert(url: Url, callback: impl FnOnce(Result)) {
									download(url, move |image| {
										convert(image, move |converted| {
											callback(converted));
										});
									});
								}
							</script>
						</code></pre>
					</section>

					<section>
						<h3>wrapped callbacks</h3>
						<pre><code data-trim data-noescape class="language-rust" >
							<script type="text/template">
								trait CallbackFuture {
									type Output;

									fn set_callback(
										&mut self,
										callback: Box<dyn FnOnce(Self::Output)>
									);
								}
							</script>
						</code></pre>

						<pre><code data-trim data-noescape class="language-rust" >
							<script type="text/template">
								struct Download {
									// â€¦
									callback: Option<Box<dyn FnOnce(Image)>>,
								}
							</script>
						</code></pre>
						<small>Actual implementation would be a bit tricky in rust.</small>

					</section>

					<section>
						<h3>callback without data</h3>
						<pre><code data-trim data-noescape class="language-rust" >
							<script type="text/template">
								trait Callback {
									fn notify_ready(&mut self);
								}
							</script>
						</code></pre>
						<pre><code data-trim data-noescape class="language-rust" >
							<script type="text/template">
								trait CallbackFuture {
									type Output;

									fn set_callback(&mut self, callback: Box<dyn Callback>);
									fn is_ready(&self) -> bool;
									fn take_output(&mut self) -> Option<Self::Output>;
								}
							</script>
						</code></pre>

					</section>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			const highlight_plugin = RevealHighlight();
			highlight_plugin.hljs.configure({tabReplace: '  '})

			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ highlight_plugin, RevealNotes ]
			});
		</script>
	</body>
</html>
